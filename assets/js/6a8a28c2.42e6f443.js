"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3668],{4535:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var i=t(4848),r=t(8453);const s={title:"Transfer Engine",description:"Conceptual guide to the data transfer engine",tags:["data-transfer","experimental"]},a=void 0,o={id:"docs/core/data-transfer/engine",title:"Transfer Engine",description:"Conceptual guide to the data transfer engine",source:"@site/docs/docs/01-core/data-transfer/01-engine.md",sourceDirName:"docs/01-core/data-transfer",slug:"/docs/core/data-transfer/engine",permalink:"/docs/core/data-transfer/engine",draft:!1,unlisted:!1,editUrl:"https://github.com/strapi/strapi/tree/main/docs/docs/docs/01-core/data-transfer/01-engine.md",tags:[{label:"data-transfer",permalink:"/tags/data-transfer"},{label:"experimental",permalink:"/tags/experimental"}],version:"current",sidebarPosition:1,frontMatter:{title:"Transfer Engine",description:"Conceptual guide to the data transfer engine",tags:["data-transfer","experimental"]},sidebar:"docs",previous:{title:"Introduction",permalink:"/docs/core/data-transfer/intro"},next:{title:"Introduction",permalink:"/docs/core/data-transfer/providers/overview"}},d={},c=[{value:"Code location",id:"code-location",level:2},{value:"The transfer process",id:"the-transfer-process",level:2},{value:"Setting up the transfer engine",id:"setting-up-the-transfer-engine",level:2},{value:"Engine Options",id:"engine-options",level:3},{value:"versionStrategy",id:"versionstrategy",level:4},{value:"schemaStrategy",id:"schemastrategy",level:4},{value:"Handling Schema differences",id:"handling-schema-differences",level:5},{value:"Progress Tracking events",id:"progress-tracking-events",level:3},{value:"Diagnostics events",id:"diagnostics-events",level:3},{value:"Transforms",id:"transforms",level:3},{value:"Filter (excluding data)",id:"filter-excluding-data",level:2},{value:"Map (modifying data)",id:"map-modifying-data",level:2},{value:"Running a transfer",id:"running-a-transfer",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"The transfer engine manages the data transfer process by facilitating communication between a source provider and a destination provider."}),"\n",(0,i.jsx)(n.h2,{id:"code-location",children:"Code location"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"packages/core/data-transfer/src/engine/index.ts"})}),"\n",(0,i.jsx)(n.h2,{id:"the-transfer-process",children:"The transfer process"}),"\n",(0,i.jsx)(n.p,{children:"A transfer starts by bootstrapping and initializing itself and the providers. That is the stage where providers attempt to make any necessary connections to files, databases, websockets, etc."}),"\n",(0,i.jsx)(n.p,{children:"After that, the integrity check between the source and destination is run, which validates the requirements set by the chosen schemaStrategy and versionStrategy."}),"\n",(0,i.jsxs)(n.p,{children:["Note: Schema differences during this stage can be resolved programmatically by adding an ",(0,i.jsx)(n.code,{children:"onSchemaDiff"})," handler. However, be aware that this interface is likely to change to a more generic engine handler (such as ",(0,i.jsx)(n.code,{children:"engine.on('schemaDiff', handler)"}),") before this feature is stable."]}),"\n",(0,i.jsx)(n.p,{children:"Once the integrity check has passed, the transfer begins by opening streams from the source to the destination one stage at a time. The following is a list of the stages in the order they are run:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"schemas - content type schemas. Note: with all built-in Strapi destination providers, only the Strapi file provider makes use of this data"}),"\n",(0,i.jsxs)(n.li,{children:["entities - all entities (including components, dynamic zones, and media data but not media files) ",(0,i.jsx)(n.em,{children:"without their relations"})]}),"\n",(0,i.jsx)(n.li,{children:"assets - the files from the /uploads folder"}),"\n",(0,i.jsx)(n.li,{children:"links - the relations between entities"}),"\n",(0,i.jsx)(n.li,{children:"configuration - the Strapi project configuration data"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Once all stages have been completed, the transfer waits for all providers to close and then emits a finish event and the transfer completes."}),"\n",(0,i.jsx)(n.h2,{id:"setting-up-the-transfer-engine",children:"Setting up the transfer engine"}),"\n",(0,i.jsxs)(n.p,{children:["A transfer engine object is created by using ",(0,i.jsx)(n.code,{children:"createTransferEngine"}),", which accepts a ",(0,i.jsx)(n.a,{href:"/docs/core/data-transfer/providers/source-providers",children:"source provider"}),", a ",(0,i.jsx)(n.a,{href:"/docs/core/data-transfer/providers/destination-providers",children:"destination provider"}),", and an options object."]}),"\n",(0,i.jsxs)(n.p,{children:["Note: By default, a transfer engine will transfer ALL data, including admin data, api tokens, etc. Transform filters must be used if you wish to exclude, as seen in the example below. An array called ",(0,i.jsx)(n.code,{children:"DEFAULT_IGNORED_CONTENT_TYPES"})," is available from @strapi/data-transfer containing the uids that are excluded by default from the import, export, and transfer commands. If you intend to transfer admin data, be aware that this behavior will likely change in the future to automatically exclude the entire ",(0,i.jsx)(n.code,{children:"admin::"})," uid namespace and will instead require them to be explicitly included."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const engine = createTransferEngine(source, destination, options);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"engine-options",children:"Engine Options"}),"\n",(0,i.jsx)(n.p,{children:"An example using every available option:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const options = {\n  versionStrategy: 'ignore', // see versionStragy documentation\n  schemaStrategy: 'strict', // see schemaStragey documentation\n  exclude: [], // exclude these classifications of data; see CLI documentation of `--exclude` for list\n  only: [], // transfer only these classifications of data; see CLI documentation of `--only` for list\n  throttle: 0, // add a delay of this many millseconds between each item transferred\n\n  // the keys of `transforms` are the stage names for which they are run\n  transforms: {\n    links: [\n      {\n        // exclude all relations to ignored content types\n        filter(link) {\n          return (\n            !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.left.type) &&\n            !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.right.type)\n          );\n        },\n      },\n      // Note: map exists for links but is not recommended\n    ],\n    entities: [\n      {\n        // exclude all ignored content types\n        filter(entity) {\n          return !DEFAULT_IGNORED_CONTENT_TYPES.includes(entity.type);\n        },\n      },\n      {\n        map(entity) {\n          // remove somePrivateField from privateThing entities\n          if (entity.type === 'api::privateThing.privateThing') {\n            entity.somePrivateField = undefined;\n          }\n\n          return entity;\n        },\n      },\n    ],\n  },\n};\n"})}),"\n",(0,i.jsx)(n.h4,{id:"versionstrategy",children:"versionStrategy"}),"\n",(0,i.jsxs)(n.p,{children:["The following ",(0,i.jsx)(n.code,{children:"versionStrategy"})," values may be used:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"'ignore'"})," - allow transfer between any versions of Strapi\n",(0,i.jsx)(n.code,{children:"'exact'"})," - require an exact version match (including tags such as -alpha and -beta)\n",(0,i.jsx)(n.code,{children:"'major'"})," - require only the semver major version to match (but allow minor, patch, and tag to differ)\n",(0,i.jsx)(n.code,{children:"'minor'"})," - require only the semver major and minor versions to match (but allow patch to differ)\n",(0,i.jsx)(n.code,{children:"'patch'"})," - require only the semver major, minor, and patch version to match (but allow tag differences such as -alpha and -beta)"]}),"\n",(0,i.jsxs)(n.p,{children:["The default ",(0,i.jsx)(n.code,{children:"versionStrategy"})," used when one is not provided is ",(0,i.jsx)(n.code,{children:"'ignore'"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"schemastrategy",children:"schemaStrategy"}),"\n",(0,i.jsxs)(n.p,{children:["The follow ",(0,i.jsx)(n.code,{children:"schemaStrategy"})," values may be used:"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"'ignore'"})," - bypass schema validation (transfer will attempt to run but throw errors on incompatible data type inserts)\n",(0,i.jsx)(n.code,{children:"'strict'"})," - disallow mismatches that are expected to cause errors in the transfer, but allow certain non-data fields in the schema to differ\n",(0,i.jsx)(n.code,{children:"'exact'"})," - schema must be identical with no changes"]}),"\n",(0,i.jsxs)(n.p,{children:['Note: The "strict" schema strategy is defined as "anything expected to cause errors in the transfer" and is the default method for the import, export, and transfer CLI commands. Therefore, the technical functionality will always be subject to change. If you need to find the definition for the current version of Strapi, see ',(0,i.jsx)(n.code,{children:"packages/core/data-transfer/src/engine/validation/schemas/index.ts"})]}),"\n",(0,i.jsxs)(n.p,{children:["The default ",(0,i.jsx)(n.code,{children:"schemaStrategy"})," used when one is not provided is ",(0,i.jsx)(n.code,{children:"'strict'"}),"."]}),"\n",(0,i.jsx)(n.h5,{id:"handling-schema-differences",children:"Handling Schema differences"}),"\n",(0,i.jsxs)(n.p,{children:["When a schema diff is discovered with a given schemaStrategy, an error is throw. However, before throwing the error the engine checks to see if there are any schema diff handlers set via ",(0,i.jsx)(n.code,{children:"engine.onSchemaDiff(handler)"})," which allows errors to be bypassed (for example, by prompting the user if they wish to proceed)."]}),"\n",(0,i.jsxs)(n.p,{children:["A diff handler is an optionally asynchronous middleware function that accepts a ",(0,i.jsx)(n.code,{children:"context"})," and a ",(0,i.jsx)(n.code,{children:"next"})," parameter."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"context"})," is an object of type ",(0,i.jsx)(n.code,{children:"SchemaDiffHandlerContext"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// type Diff can be found in /packages/core/data-transfer/src/utils/json.ts\ntype SchemaDiffHandlerContext = {\n  ignoredDiffs: Record<string, Diff[]>;\n  diffs: Record<string, Diff[]>;\n  source: ISourceProvider;\n  destination: IDestinationProvider;\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"next"})," is a function that is called, passing the modified ",(0,i.jsx)(n.code,{children:"context"})," object, to proceed to the next middleware function."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const diffHandler = async (context, next) => {\n  const ignoreThese = {};\n  // loop through the diffs\n  Object.entries(context.diffs).forEach(([uid, diffs]) => {\n    for (const [i, diff] of diffs) {\n      // get the path of the diff in the schema\n      const path = [uid].concat(diff.path).join('.');\n\n      // Allow a diff on the country schema displayName\n      if (path === 'api::country.country.info.displayName') {\n        if (!isArray(context.ignoredDiffs[uid])) {\n          context.ignoredDiffs[uid] = [];\n        }\n        context.ignoredDiffs[uid][i] = diff;\n      }\n    }\n  });\n\n  return next(context);\n};\n\nengine.onSchemaDiff(diffHandler);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["After all the schemaDiffHandler middlewares have been run, another diff is run between ",(0,i.jsx)(n.code,{children:"context.ignoredDiffs"})," and ",(0,i.jsx)(n.code,{children:"context.diffs"})," and any remaining diffs that have not been ignored are thrown as fatal errors and the engine will abort the transfer."]}),"\n",(0,i.jsx)(n.h3,{id:"progress-tracking-events",children:"Progress Tracking events"}),"\n",(0,i.jsx)(n.p,{children:"The transfer engine allows tracking the progress of your transfer either directly with the engine.progress.data object, or with listeners using the engine.progress.stream PassThrough stream. The engine.progress.data object definition is of type TransferProgress."}),"\n",(0,i.jsx)(n.p,{children:"Here is an example that logs a message at the beginning and end of each stage, as well as a message after each item has been transferred"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const progress = engine.progress.stream;\n\nprogress.on(`stage::start`, ({ stage, data }) => {\n  console.log(`${stage} has started at ${data[stage].startTime}`);\n});\n\nprogress.on('stage::finish', ({ stage, data }) => {\n  console.log(`${stage} has finished at ${data[stage].endTime}`);\n});\n\nprogress.on('stage::progress', ({ stage, data }) => {\n  console.log('Transferred ${data[stage].bytes} bytes / ${data[stage].count} entities');\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:'Note: There is currently no way for a source provider to give a "total" number of records expected to be transferred, but it is expected in a future update.'}),"\n",(0,i.jsx)(n.p,{children:"The following events are available:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"stage::start"})," - at the start of each stage\n",(0,i.jsx)(n.code,{children:"stage::finish"})," - at the end of each stage\n",(0,i.jsx)(n.code,{children:"stage::progress"})," - after each entitity in that stage has been transferred\n",(0,i.jsx)(n.code,{children:"stage::skip"})," - when an entire stage is skipped (eg, when 'only' or 'exclude' are used)\n",(0,i.jsx)(n.code,{children:"stage::error"})," - when there is an error thrown during a stage\n",(0,i.jsx)(n.code,{children:"transfer::init"})," - at the very beginning of engine.transfer()\n",(0,i.jsx)(n.code,{children:"transfer::start"})," - after bootstrapping and initializing the providers, when the transfer is about to start\n",(0,i.jsx)(n.code,{children:"transfer::finish"})," - when the transfer has finished\n",(0,i.jsx)(n.code,{children:"transfer::error"})," - when there is an error thrown during the transfer"]}),"\n",(0,i.jsx)(n.h3,{id:"diagnostics-events",children:"Diagnostics events"}),"\n",(0,i.jsx)(n.p,{children:"The engine includes a diagnostics reporter which can be used to listen for diagnostics information (debug messages, errors, etc)."}),"\n",(0,i.jsx)(n.p,{children:"Here is an example for creating a diagnostics listener:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// listener function\nconst diagnosticListener: DiagnosticListener = (data: GenericDiagnostic) => {\n  // handle the diagnostics event, for example with custom logging\n};\n\n// add a generic listener\nengine.diagnostics.onDiagnostic(diagnosticsListener);\n\n// add an error listener\nengine.diagnostics.on('error', diagnosticListener);\n\n// add a warning listener\nengine.diagnostics.on('warning', diagnosticListener);\n"})}),"\n",(0,i.jsx)(n.p,{children:"To emit your own diagnostics event:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const event: ErrorDiagnostic = {\n  kind: 'error',\n  details: {\n    message: 'Your diagnostics message'\n    createdAt: new Date(),\n  },\n  name: 'yourError',\n  severity: 'fatal',\n  error: new Error('your error message')\n}\n\nengine.diagnostics.report(event);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here is an excerpt of the relevant types used in the previous examples:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// engine/diagnostic.ts\n// format of the data sent to the listener\nexport type GenericDiagnostic<K extends DiagnosticKind, T = unknown> = {\n  kind: K;\n  details: {\n    message: string;\n    createdAt: Date;\n  } & T;\n};\n\nexport type DiagnosticKind = 'error' | 'warning' | 'info';\n\nexport type Diagnostic = ErrorDiagnostic | WarningDiagnostic | InfoDiagnostic;\n\nexport type ErrorDiagnosticSeverity = 'fatal' | 'error' | 'silly';\n\nexport type ErrorDiagnostic = GenericDiagnostic<\n  'error',\n  {\n    name: string;\n    severity: ErrorDiagnosticSeverity;\n    error: Error;\n  }\n>;\n\nexport type WarningDiagnostic = GenericDiagnostic<\n  'warning',\n  {\n    origin?: string;\n  }\n>;\n\nexport type InfoDiagnostic<T = unknown> = GenericDiagnostic<\n  'info',\n  {\n    params?: T;\n  }\n>;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"transforms",children:"Transforms"}),"\n",(0,i.jsx)(n.p,{children:"Transforms allow you to manipulate the data that is sent from the source before it reaches the destination."}),"\n",(0,i.jsx)(n.h2,{id:"filter-excluding-data",children:"Filter (excluding data)"}),"\n",(0,i.jsxs)(n.p,{children:["Filters can be used to exclude data sent from the source before it is streamed to the destination. They are methods that accept an entity, link, schema, etc and return ",(0,i.jsx)(n.code,{children:"true"})," to keep the entity and ",(0,i.jsx)(n.code,{children:"false"})," to remove it."]}),"\n",(0,i.jsx)(n.p,{children:"Here is an example that filters out all entities with an id higher than 100:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const options = {\n  ...otherOptions,\n  transforms: {\n    entities: [\n      {\n        // exclude all ignored admin content types\n        filter(entity) {\n          return !DEFAULT_IGNORED_CONTENT_TYPES.includes(entity.type);\n        },\n      },\n      {\n        // exclude all entities with an id higher than 100\n        filter(entity) {\n          return Number(entity.id) <= 100;\n        },\n      },\n    ],\n    links: [\n      {\n        // exclude all relations to ignored content types\n        filter(link) {\n          return (\n            !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.left.type) &&\n            !DEFAULT_IGNORED_CONTENT_TYPES.includes(link.right.type)\n          );\n        },\n      },\n      {\n        // remember to exclude links as well or else an error will be thrown when attempting to link an entity we filtered\n        filter(entity) {\n          return Number(link.left.id) <= 100 || Number(link.right.id) <= 100)\n        },\n      },\n    ],\n  },\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"map-modifying-data",children:"Map (modifying data)"}),"\n",(0,i.jsx)(n.p,{children:"Maps can be used to modify data sent from the source before it is streamed to the destination. They are methods that accept an entity, link, schema, etc and return the modified version of the object."}),"\n",(0,i.jsx)(n.p,{children:"This can be used, for example, to sanitize data between environments."}),"\n",(0,i.jsxs)(n.p,{children:["Here is an example that removes a field called ",(0,i.jsx)(n.code,{children:"somePrivateField"})," from a content type ",(0,i.jsx)(n.code,{children:"privateThing"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const options = {\n  ...otherOptions,\n  transforms: {\n    entities: [\n      {\n        // exclude all ignored content types\n        filter(entity) {\n          return !DEFAULT_IGNORED_CONTENT_TYPES.includes(entity.type);\n        },\n      },\n      {\n        map(entity) {\n          // remove somePrivateField from privateThing entities\n          if (entity.type === 'api::privateThing.privateThing') {\n            entity.somePrivateField = undefined;\n          }\n\n          return entity;\n        },\n      },\n    ],\n  },\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"By mapping schemas as well as entities, it's even possible (although complex!) to modify data structures between source and destination."}),"\n",(0,i.jsx)(n.h2,{id:"running-a-transfer",children:"Running a transfer"}),"\n",(0,i.jsx)(n.p,{children:"Running a transfer simply involves calling the asynchrounous engine.transfer() method."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const engine = createTransferEngine(source, destination, options);\ntry {\n  await engine.transfer();\n} catch (e) {\n  console.error('Something went wrong: ', e?.message);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Be aware that engine.transfer() throws on any fatal errors it encounters."}),"\n",(0,i.jsxs)(n.p,{children:["Note: The transfer engine (and the providers) current only support a single ",(0,i.jsx)(n.code,{children:"engine.transfer()"})," and must be re-instantiated if intended to run multiple times. In the future it is expected to allow them to be used for multiple transfers in a row, but that usage is untested and will result in unpredictable behavior."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);