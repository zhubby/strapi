"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6650],{9397:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var n=s(4848),i=s(8453);const a={title:"Content Releases Scheduling",description:"Content Releases Scheduling",tags:["content-releases","tech design"]},r=void 0,o={id:"docs/core/content-releases/scheduling",title:"Content Releases Scheduling",description:"Content Releases Scheduling",source:"@site/docs/docs/01-core/content-releases/03-scheduling.md",sourceDirName:"docs/01-core/content-releases",slug:"/docs/core/content-releases/scheduling",permalink:"/docs/core/content-releases/scheduling",draft:!1,unlisted:!1,editUrl:"https://github.com/strapi/strapi/tree/main/docs/docs/docs/01-core/content-releases/03-scheduling.md",tags:[{label:"content-releases",permalink:"/tags/content-releases"},{label:"tech design",permalink:"/tags/tech-design"}],version:"current",sidebarPosition:3,frontMatter:{title:"Content Releases Scheduling",description:"Content Releases Scheduling",tags:["content-releases","tech design"]},sidebar:"docs",previous:{title:"Release details page",permalink:"/docs/core/content-releases/frontend/release-details-page"},next:{title:"Introduction",permalink:"/docs/core/content-type-builder/intro"}},l={},c=[{value:"How it works",id:"how-it-works",level:2},{value:"Timezones",id:"timezones",level:2},{value:"Scheduling in a architecture with multiple Strapi instances",id:"scheduling-in-a-architecture-with-multiple-strapi-instances",level:2},{value:"Release scheduled on runtime",id:"release-scheduled-on-runtime",level:3},{value:"Starting a strapi instance",id:"starting-a-strapi-instance",level:3}];function h(e){const t={admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.admonition,{type:"caution",children:(0,n.jsxs)(t.p,{children:["Content Releases Scheduling is not yet a stable feature. Therefore, all the elements documented on this page are not currently visible. If you wish to try Releases Scheduling, you can enable it ",(0,n.jsx)(t.strong,{children:"at your own"})," risk using the ",(0,n.jsx)(t.code,{children:"contentReleasesScheduling"})," feature flag."]})}),"\n",(0,n.jsx)(t.p,{children:"Scheduling provides users with the ability to set a scheduled date for the release, automating its publication or unpublishing. When this happens, a webhook is triggered, providing the result of the attempt to publish the release."}),"\n",(0,n.jsx)(t.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,n.jsx)(t.p,{children:"Everytime you create or update a release and add a scheduled date, the server responsible for handling this request will generate a new cronjob (utilizing node-schedule) for the selected date to publish the release."}),"\n",(0,n.jsx)(t.h2,{id:"timezones",children:"Timezones"}),"\n",(0,n.jsx)(t.p,{children:'When selecting a scheduled date, you have the option to choose a specific timezone; by default, your system timezone is selected. This measure is taken to prevent any potential confusion when selecting the publication time for a release. Consequently, if a user sets a schedule for 16:00 using the "Europe/Paris" timezone (UTC+01:00), another user accessing the same release will see the same time (16:00 (UTC+01:00)), regardless of their system\'s timezone.'}),"\n",(0,n.jsx)(t.h2,{id:"scheduling-in-a-architecture-with-multiple-strapi-instances",children:"Scheduling in a architecture with multiple Strapi instances"}),"\n",(0,n.jsx)(t.p,{children:"It's possible that your Strapi project runs on multiple instances. In such cases, what happens with the cronjobs? Do they all run simultaneously, attempting to publish the release multiple times? To understand how we address this scenario, it's important to differentiate between two cases when scheduling a release:"}),"\n",(0,n.jsx)(t.h3,{id:"release-scheduled-on-runtime",children:"Release scheduled on runtime"}),"\n",(0,n.jsx)(t.p,{children:"If you have 3 Strapi instances running concurrently, and you distribute traffic among them using any method, there is not a big problem. This is because the server responsible for handling one request to create/update a release and add a schedule will be the only server with the associated cronjob. Then, there's no duplication, and potential race condition problems are avoided."}),"\n",(0,n.jsx)(t.h3,{id:"starting-a-strapi-instance",children:"Starting a strapi instance"}),"\n",(0,n.jsx)(t.p,{children:"The problem is starting a new Strapi instance, because we retrieve all scheduled releases and ensure that cronjobs are created for each one. Consequently, multiple Strapi instances might end up with the same cronjob for a release publish. To address this, we implement the following logic:"}),"\n",(0,n.jsx)("img",{src:"/img/content-manager/content-releases/scheduling-publish.png",alt:"a diagram overview explaining the publish release flow"}),"\n",(0,n.jsx)(t.p,{children:"We set up a transaction that locks the release being published using SQL forUpdate. This means that any other processes attempting to access the release row will be put on hold until the first one finishes executing."}),"\n",(0,n.jsx)(t.p,{children:"If the validation of the release entries is successful, the publish action proceeds smoothly. In this scenario, we update the releasedAt column of the release with the current date and release the row lock. Subsequently, any incoming processes attempting to access the release would simply encounter an error because the release has already been published."}),"\n",(0,n.jsx)(t.p,{children:'On the other hand, if the publish process fails, we update the release\'s status to "failed". When the status is marked as failed, any subsequent attempts to publish will fail silently. The "failed" status only changes when a user makes alterations to the release.'})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>o});var n=s(6540);const i={},a=n.createContext(i);function r(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);